# 2-3. 複雑な値

## 配列

Go の配列は固定長。
0-indexed。

```go
// int 型の 3 要素の配列 a
var a [3]int

// 宣言と同時に初期化
var b [3]int = [3]int{1, 2, 3}

// 使い方
fmt.Println(b[1])   // => 2
b[0] = 42
```

> ```go
> var 変数 [ 要素数 ] 型 { 値1, 値2, …… }
> ```

じゃないじゃん（p.85）

```go
var 変数 = [ 要素数 ] 型 { 値1, 値2, …… }
```
なら通る。

配列 `a` に対して `len(a)` で要素数を得られる。

### `range`

`range` を使うことで、インデックスと値を得られる。
```go
a := [...]int{4, 5, 6}
for i, x := range a {
    fmt.Println(i, x)
}
```
とすると、次のような出力になる。
```
0 4
1 5
2 6
```

インデックスが要らない場合はアンダースコア `_` にして捨てる。
```go
for _, x := range a {
    fmt.Println(x)
}
```

> Go では、アンダースコアで始まる変数は、他の変数とは少し違います。これは、 **「使わなくてもいい変数」** なのです。

エラーになったが？（p.90）

```console
$ go run for-range-2.go
# command-line-arguments
./for-range-2.go:7:6: _i declared but not used
```

## スライス

動的な配列

配列の宣言で、要素数を省略するとスライスになる。
```go
array := []int {1,2,3}
```

配列 `a` に対して `a[i:j]` で `a[i]` から `a[j-1]` までの要素のスライスができる。
```go
a := [5]int {1,2,3,4,5}
b := a[1:3] // => [2, 3]
```

`b` がスライス。

`a[i:]` で `a[i]` から末尾までの、`a[:j]` で先頭から `a[j-1]` までのスライスになる。
`a[:0]` は空のスライスになる。
